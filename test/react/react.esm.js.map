{
  "version": 3,
  "sources": ["../../packages/shared/src/utils.ts", "../../packages/types/src/nodeType.ts", "../../packages/types/src/effectType.ts", "../../packages/react/index.ts"],
  "sourcesContent": ["function isObject(value : any) : boolean {\r\n  return typeof value === 'object'\r\n}\r\n\r\nfunction isNumber(value : any) : boolean {\r\n  return !isNaN(value) && typeof value === 'number'\r\n}\r\n\r\nfunction isString(value : any) : boolean {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isBoolean(value : any) : boolean {\r\n  return typeof value === 'boolean'\r\n}\r\n\r\nfunction isArray(value : any) : boolean {\r\n  return Array.isArray(value)\r\n}\r\n\r\nfunction isFunction(value : any) : boolean {\r\n  return typeof value === 'function'\r\n}\r\n\r\nfunction toUppercaseStart(value : string) : string {\r\n  if(value) {\r\n    value = value.replace(value[0],value[0].toUpperCase());\r\n  }\r\n  return value\r\n}\r\n\r\nfunction isUppercaseStart(value : string) : boolean {\r\n  if(value) {\r\n    const c = value.charAt(0)\r\n    if(c >= \"A\" && c <= \"Z\") {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction hasOwnProperty(value : any,key : any) : boolean {\r\n  return Object.prototype.hasOwnProperty.call(value,key)\r\n} \r\n\r\nfunction removeExtraSpaces(value : string) : string {\r\n  return value.replace(/[\\s]+/g,\"\")\r\n}\r\n\r\nfunction getLongestIncreasingSequence(arr : Array<number>) : Array<number> {\r\n  const len = arr.length\r\n  const result = [0]\r\n  const traceBack = new Array(len)\r\n  let startIndex\r\n  let endIndex\r\n  let middleIndex\r\n  let resultLastIndex;\r\n  for(let i = 0; i < len; i++) {\r\n    let item = arr[i]\r\n    if(item === 0) {\r\n      continue\r\n    }\r\n    resultLastIndex = result[result.length - 1]\r\n    if(arr[resultLastIndex] < item) {\r\n      result.push(i)\r\n      traceBack[i] = resultLastIndex\r\n      continue\r\n    }\r\n\r\n    startIndex = 0\r\n    endIndex = result.length - 1\r\n    while(startIndex < endIndex) {\r\n      middleIndex = ((startIndex + endIndex) / 2) | 0\r\n      if(arr[result[middleIndex]] < item) {\r\n        startIndex = middleIndex  + 1\r\n      } else {\r\n        endIndex = middleIndex\r\n      }\r\n    }\r\n\r\n    if(arr[result[endIndex]] > item) {\r\n      result[endIndex] = i\r\n      traceBack[i] = result[endIndex - 1]\r\n    }\r\n  }\r\n\r\n  let i = result.length\r\n  let last = result[i - 1]\r\n  while(i-- > 0) {\r\n    result[i] = last\r\n    last = traceBack[last]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction invokeFunctions(funs : Array<Function>) {\r\n  for(let i = 0; i < funs.length; i++) {\r\n    const fun = funs[i]\r\n    fun()\r\n  }\r\n}\r\n\r\nfunction onlyOne(items : any) {\r\n  return isArray(items) ? items[0] : items\r\n}\r\n\r\nfunction flatten(array : Array<any>) {\r\n  const flatted : Array<any> = []\r\n  function flat(items : Array<any>) {\r\n    items.forEach(item => {\r\n      if(isArray(item)) {\r\n        flat(item)\r\n      } else {\r\n        flatted.push(item)\r\n      }\r\n    })\r\n  }\r\n  flat(array)\r\n  return flatted\r\n}\r\n\r\nexport {\r\n  isObject,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  isArray,\r\n  isFunction,\r\n  hasOwnProperty,\r\n  toUppercaseStart,\r\n  isUppercaseStart,\r\n  removeExtraSpaces,\r\n  getLongestIncreasingSequence,\r\n  invokeFunctions,\r\n  onlyOne,\r\n  flatten,\r\n}", "const TEXT = Symbol.for(\"TEXT\")\r\n\r\n\r\nconst TAG_ROOT = Symbol.for(\"TAG_ROOT\")\r\nconst TAG_ELEMENT = Symbol.for(\"TAG_ELEMENT\")\r\nconst TAG_TEXT = Symbol.for(\"TAG_TEXT\")\r\nconst TAG_COMMENT = Symbol.for(\"TAG_COMMENT\")\r\n\r\nexport {\r\n  TEXT,\r\n\r\n  TAG_ROOT,\r\n  TAG_ELEMENT,\r\n  TAG_TEXT,\r\n  TAG_COMMENT,\r\n}", "const PLACEMENT = Symbol.for(\"PLACEMENT\")\r\nconst UPDATE = Symbol.for(\"PLACEMENT\")\r\nconst DELETION = Symbol.for(\"PLACEMENT\")\r\n\r\nexport {\r\n  PLACEMENT,\r\n  UPDATE,\r\n  DELETION,\r\n}", "import { isFunction, isObject } from \"../shared\"\r\nimport { TEXT } from \"../types\"\r\n\r\nfunction createElement(type : any,config : any,...children : Array<any>) {\r\n  return {\r\n    type,\r\n    props: {\r\n      ...config\r\n    },\r\n    children : children.map(child => {\r\n      if(isObject(child) || isFunction(child)) {\r\n        return child\r\n      }\r\n      return {\r\n        type: TEXT,\r\n        props: {\r\n        },\r\n        children: child\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport {\r\n  createElement,\r\n}"],
  "mappings": ";AAAA,SAAS,SAAS,OAAuB;AACvC,SAAO,OAAO,UAAU;AAC1B;AAkBA,SAAS,WAAW,OAAuB;AACzC,SAAO,OAAO,UAAU;AAC1B;;;ACtBA,IAAM,OAAO,OAAO,IAAI,MAAM;AAG9B,IAAM,WAAW,OAAO,IAAI,UAAU;AACtC,IAAM,cAAc,OAAO,IAAI,aAAa;AAC5C,IAAM,WAAW,OAAO,IAAI,UAAU;AACtC,IAAM,cAAc,OAAO,IAAI,aAAa;;;ACN5C,IAAM,YAAY,OAAO,IAAI,WAAW;AACxC,IAAM,SAAS,OAAO,IAAI,WAAW;AACrC,IAAM,WAAW,OAAO,IAAI,WAAW;;;ACCvC,SAAS,cAAc,MAAW,WAAgB,UAAuB;AACvE,SAAO;AAAA,IACL;AAAA,IACA,OAAO;AAAA,MACL,GAAG;AAAA,IACL;AAAA,IACA,UAAW,SAAS,IAAI,WAAS;AAC/B,UAAG,SAAS,KAAK,KAAK,WAAW,KAAK,GAAG;AACvC,eAAO;AAAA,MACT;AACA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,CACP;AAAA,QACA,UAAU;AAAA,MACZ;AAAA,IACF,CAAC;AAAA,EACH;AACF;",
  "names": []
}
