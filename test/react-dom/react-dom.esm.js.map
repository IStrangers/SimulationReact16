{
  "version": 3,
  "sources": ["../../packages/shared/src/utils.ts", "../../packages/types/src/nodeType.ts", "../../packages/types/src/effectType.ts", "../../packages/react/src/updater.ts", "../../packages/react/src/scheduler.ts", "../../packages/react-dom/index.ts"],
  "sourcesContent": ["function isObject(value : any) : boolean {\r\n  return typeof value === 'object'\r\n}\r\n\r\nfunction isNumber(value : any) : boolean {\r\n  return !isNaN(value) && typeof value === 'number'\r\n}\r\n\r\nfunction isString(value : any) : boolean {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isBoolean(value : any) : boolean {\r\n  return typeof value === 'boolean'\r\n}\r\n\r\nfunction isArray(value : any) : boolean {\r\n  return Array.isArray(value)\r\n}\r\n\r\nfunction isFunction(value : any) : boolean {\r\n  return typeof value === 'function'\r\n}\r\n\r\nfunction toUppercaseStart(value : string) : string {\r\n  if(value) {\r\n    value = value.replace(value[0],value[0].toUpperCase());\r\n  }\r\n  return value\r\n}\r\n\r\nfunction isUppercaseStart(value : string) : boolean {\r\n  if(value) {\r\n    const c = value.charAt(0)\r\n    if(c >= \"A\" && c <= \"Z\") {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction hasOwnProperty(value : any,key : any) : boolean {\r\n  return Object.prototype.hasOwnProperty.call(value,key)\r\n} \r\n\r\nfunction removeExtraSpaces(value : string) : string {\r\n  return value.replace(/[\\s]+/g,\"\")\r\n}\r\n\r\nfunction getLongestIncreasingSequence(arr : Array<number>) : Array<number> {\r\n  const len = arr.length\r\n  const result = [0]\r\n  const traceBack = new Array(len)\r\n  let startIndex\r\n  let endIndex\r\n  let middleIndex\r\n  let resultLastIndex;\r\n  for(let i = 0; i < len; i++) {\r\n    let item = arr[i]\r\n    if(item === 0) {\r\n      continue\r\n    }\r\n    resultLastIndex = result[result.length - 1]\r\n    if(arr[resultLastIndex] < item) {\r\n      result.push(i)\r\n      traceBack[i] = resultLastIndex\r\n      continue\r\n    }\r\n\r\n    startIndex = 0\r\n    endIndex = result.length - 1\r\n    while(startIndex < endIndex) {\r\n      middleIndex = ((startIndex + endIndex) / 2) | 0\r\n      if(arr[result[middleIndex]] < item) {\r\n        startIndex = middleIndex  + 1\r\n      } else {\r\n        endIndex = middleIndex\r\n      }\r\n    }\r\n\r\n    if(arr[result[endIndex]] > item) {\r\n      result[endIndex] = i\r\n      traceBack[i] = result[endIndex - 1]\r\n    }\r\n  }\r\n\r\n  let i = result.length\r\n  let last = result[i - 1]\r\n  while(i-- > 0) {\r\n    result[i] = last\r\n    last = traceBack[last]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction invokeFunctions(funs : Array<Function>) {\r\n  for(let i = 0; i < funs.length; i++) {\r\n    const fun = funs[i]\r\n    fun()\r\n  }\r\n}\r\n\r\nfunction onlyOne(items : any) {\r\n  return isArray(items) ? items[0] : items\r\n}\r\n\r\nfunction flatten(array : Array<any>) {\r\n  const flatted : Array<any> = []\r\n  function flat(items : Array<any>) {\r\n    items.forEach(item => {\r\n      if(isArray(item)) {\r\n        flat(item)\r\n      } else {\r\n        flatted.push(item)\r\n      }\r\n    })\r\n  }\r\n  flat(array)\r\n  return flatted\r\n}\r\n\r\nexport {\r\n  isObject,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  isArray,\r\n  isFunction,\r\n  hasOwnProperty,\r\n  toUppercaseStart,\r\n  isUppercaseStart,\r\n  removeExtraSpaces,\r\n  getLongestIncreasingSequence,\r\n  invokeFunctions,\r\n  onlyOne,\r\n  flatten,\r\n}", "const TEXT = Symbol.for(\"TEXT\")\r\n\r\n\r\nconst TAG_ROOT = Symbol.for(\"TAG_ROOT\")\r\nconst TAG_ELEMENT = Symbol.for(\"TAG_ELEMENT\")\r\nconst TAG_TEXT = Symbol.for(\"TAG_TEXT\")\r\nconst TAG_COMMENT = Symbol.for(\"TAG_COMMENT\")\r\nconst TAG_CLASS_COMPONENT = Symbol.for(\"TAG_CLASS_COMPONENT\")\r\nconst TAG_FUNCTION_COMPONENT = Symbol.for(\"TAG_FUNCTION_COMPONENT\")\r\nexport {\r\n  TEXT,\r\n\r\n  TAG_ROOT,\r\n  TAG_ELEMENT,\r\n  TAG_TEXT,\r\n  TAG_COMMENT,\r\n  TAG_CLASS_COMPONENT,\r\n  TAG_FUNCTION_COMPONENT,\r\n}", "const PLACEMENT = Symbol.for(\"PLACEMENT\")\r\nconst UPDATE = Symbol.for(\"UPDATE\")\r\nconst DELETION = Symbol.for(\"DELETION\")\r\n\r\nexport {\r\n  PLACEMENT,\r\n  UPDATE,\r\n  DELETION,\r\n}", "import { isFunction } from \"../../shared\"\r\n\r\nclass Updater {\r\n\r\n  public nextUpdater : Updater | null = null\r\n\r\n  constructor(public payload : any) {\r\n\r\n  }\r\n  \r\n}\r\n\r\nclass UpdaterQueue {\r\n\r\n  public firstUpdater : Updater | null = null\r\n  public lastUpdater : Updater | null = null\r\n\r\n  enqueueUpdate(updater : Updater) {\r\n    if(this.lastUpdater === null) {\r\n      this.firstUpdater = this.lastUpdater = updater\r\n    } else {\r\n      this.lastUpdater.nextUpdater = updater\r\n      this.lastUpdater = updater\r\n    }\r\n  }\r\n\r\n  forceUpdate(state : any) {\r\n    let currentUpdater = this.firstUpdater\r\n    while(currentUpdater) {\r\n      const nextState = isFunction(currentUpdater.payload) ? currentUpdater.payload(state) : currentUpdater.payload\r\n      state = { ...state,...nextState}\r\n      currentUpdater = currentUpdater.nextUpdater\r\n    }\r\n    this.firstUpdater = this.lastUpdater = null\r\n    return state\r\n  }\r\n}\r\n\r\nexport {\r\n  Updater,\r\n  UpdaterQueue,\r\n}", "import { hasOwnProperty, isFunction, isString } from \"../../shared\"\r\nimport { DELETION, PLACEMENT, TAG_CLASS_COMPONENT, TAG_COMMENT, TAG_ELEMENT, TAG_FUNCTION_COMPONENT, TAG_ROOT, TAG_TEXT, TEXT, UPDATE } from \"../../types\"\r\nimport { UpdaterQueue } from \"./updater\"\r\n\r\nexport let workInProgressRoot : any = null\r\nexport let nextUnitOfWork : any = null\r\nexport let currentRoot : any = null\r\nexport const deletions : Array<any> = []\r\n\r\nfunction startWork() {\r\n  requestIdleCallback(workLoop,{ timeout: 500 })\r\n}\r\nstartWork()\r\n\r\nfunction workLoop(deadline : any) {\r\n  let shouldYield = false\r\n  while(nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\r\n    shouldYield = deadline.timeRemaining() < 1\r\n  }\r\n  if(!nextUnitOfWork && workInProgressRoot) {\r\n    commitRoot()\r\n  }\r\n  startWork()\r\n}\r\n\r\nfunction commitRoot() {\r\n  deletions.forEach(commitWork)\r\n  let currentFiber = workInProgressRoot.firstEffect\r\n  while(currentFiber) {\r\n    commitWork(currentFiber)\r\n    currentFiber = currentFiber.nextEffect\r\n  }\r\n  deletions.length = 0\r\n  currentRoot = workInProgressRoot\r\n  workInProgressRoot = null\r\n}\r\n\r\nfunction commitWork(currentFiber : any) {\r\n  if(!currentFiber) return\r\n  const  { \r\n    tag,effectTag,stateNode,\r\n    props,type,children,alternate \r\n  } = currentFiber\r\n  let parentFiber = currentFiber.parent\r\n  while(\r\n    parentFiber.tag !== TAG_ELEMENT && \r\n    parentFiber.tag !== TAG_ROOT &&\r\n    parentFiber.tag !== TAG_TEXT\r\n  ) {\r\n    parentFiber = parentFiber.parent\r\n  }\r\n  const parentNode = parentFiber.stateNode\r\n  if(effectTag === PLACEMENT) {\r\n    let nextFiber = currentFiber\r\n    while(nextFiber.tag !== TAG_ELEMENT && nextFiber.tag !== TAG_TEXT) {\r\n      nextFiber = currentFiber.child\r\n    }\r\n    parentNode.appendChild(nextFiber.stateNode)\r\n  } else if(effectTag === DELETION) {\r\n    commitDeletion(currentFiber,parentNode)\r\n  } else if(effectTag === UPDATE) {\r\n    if(type === TEXT && children !== alternate.children) {\r\n      stateNode.textContent = children\r\n    } else if(tag !== TAG_CLASS_COMPONENT) {\r\n      updateDOM(stateNode,alternate.props,props)\r\n    }\r\n  }\r\n  currentFiber.effectTag = null\r\n}\r\n\r\nfunction commitDeletion(currentFiber : any,parentNode : Node) {\r\n  if(currentFiber.tag === TAG_ELEMENT && currentFiber.tag === TAG_TEXT) {\r\n    parentNode.removeChild(currentFiber.stateNode)\r\n  } else {\r\n    commitDeletion(currentFiber.child,parentNode)\r\n  }\r\n}\r\n\r\nfunction performUnitOfWork(currentFiber : any) {\r\n  beginWork(currentFiber)\r\n  if(currentFiber.child) {\r\n    return currentFiber.child\r\n  }\r\n  while(currentFiber) {\r\n    completeUnitOfWork(currentFiber)\r\n    if(currentFiber.sibling) {\r\n      return currentFiber.sibling\r\n    }\r\n    currentFiber = currentFiber.parent\r\n  }\r\n}\r\n\r\nfunction completeUnitOfWork(currentFiber : any) {\r\n  const { parent: parentFiber,effectTag } = currentFiber\r\n  if(parentFiber) {\r\n    if(!parentFiber.firstEffect) {\r\n      parentFiber.firstEffect = currentFiber.firstEffect\r\n    }\r\n    if(currentFiber.lastEffect) {\r\n      if(parentFiber.lastEffect) {\r\n        parentFiber.lastEffect.nextEffect = currentFiber.firstEffect\r\n      }\r\n      parentFiber.lastEffect = currentFiber.lastEffect\r\n    }\r\n    if(effectTag) {\r\n      if(parentFiber.lastEffect) {\r\n        parentFiber.lastEffect.nextEffect = currentFiber\r\n      } else {\r\n        parentFiber.firstEffect = currentFiber\r\n      }\r\n      parentFiber.lastEffect = currentFiber\r\n    }\r\n  }\r\n}\r\n\r\nfunction beginWork(currentFiber : any) {\r\n  const { tag } = currentFiber\r\n  if(tag === TAG_ROOT) {\r\n    updateHostRoot(currentFiber)\r\n  } else if(tag === TAG_TEXT) {\r\n    updateHostText(currentFiber)\r\n  } else if(tag === TAG_ELEMENT) {\r\n    updateHostElement(currentFiber)\r\n  } else if(tag === TAG_CLASS_COMPONENT) {\r\n    updateClassComponent(currentFiber)\r\n  } else if(tag === TAG_FUNCTION_COMPONENT) {\r\n    updateFunctionComponent(currentFiber)\r\n  }\r\n}\r\n\r\nfunction updateFunctionComponent(currentFiber : any) {\r\n\r\n}\r\n\r\nfunction updateClassComponent(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = new currentFiber.type(currentFiber.props)\r\n    currentFiber.stateNode.internalFiber = currentFiber\r\n    currentFiber.updaterQueue = new UpdaterQueue()\r\n  }\r\n  currentFiber.stateNode.state = currentFiber.updaterQueue.forceUpdate(currentFiber.stateNode.state)\r\n  const newElement = currentFiber.stateNode.render()\r\n  const newChildren = [ newElement ]\r\n  reconcileChildren(currentFiber,newChildren)\r\n}\r\n\r\nfunction updateHostElement(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = createDOM(currentFiber)\r\n  } \r\n  const children = currentFiber.children\r\n  reconcileChildren(currentFiber,children)\r\n}\r\n\r\nfunction updateHostText(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = createDOM(currentFiber)\r\n  }\r\n}\r\n\r\nfunction updateHostRoot(currentFiber : any) {\r\n  const children = currentFiber.children\r\n  reconcileChildren(currentFiber,children)\r\n}\r\n\r\nfunction reconcileChildren(currentFiber : any,children : Array<any>) {\r\n  let childrenIndex = 0\r\n  let oldFiber = currentFiber.alternate && currentFiber.alternate.child\r\n  if(oldFiber) {\r\n    oldFiber.firstEffect = oldFiber.lastEffect = oldFiber.nextEffect = null\r\n  }\r\n  let prevSibling : any\r\n  while(childrenIndex < children.length) {\r\n    const newChild = children[childrenIndex++]\r\n    const sameType = oldFiber && newChild && oldFiber.type === newChild.type\r\n\r\n    let newFiber\r\n    if(sameType) {\r\n      if(oldFiber.alternate) {\r\n        newFiber = oldFiber.alternate\r\n        newFiber.props = newChild.props\r\n        newFiber.children = newChild.children\r\n        newFiber.alternate = oldFiber\r\n        newFiber.effectTag = UPDATE\r\n        newFiber.updaterQueue = oldFiber.updaterQueue || new UpdaterQueue()\r\n        newFiber.nextEffect = null\r\n      } else {\r\n        newFiber = {\r\n          tag: oldFiber.tag,\r\n          type: oldFiber.type,\r\n          props: newChild.props,\r\n          children: newChild.children,\r\n          stateNode: oldFiber.stateNode,\r\n          parent: currentFiber,\r\n          updaterQueue: oldFiber.updaterQueue || new UpdaterQueue(),\r\n          alternate: oldFiber,\r\n          effectTag: UPDATE,\r\n          nextEffect: null\r\n        }\r\n      }\r\n    } else if(newChild){\r\n      let tag : Symbol\r\n      if(newChild && isFunction(newChild.type)) {\r\n        tag = newChild.type.prototype.isReactComponent ? TAG_CLASS_COMPONENT : TAG_FUNCTION_COMPONENT\r\n      } else if(newChild.type === TEXT) {\r\n        tag = TAG_TEXT\r\n      } else if(isString(newChild.type)) {\r\n        tag = TAG_ELEMENT\r\n      } else {\r\n        tag = TAG_COMMENT\r\n      }\r\n      newFiber = {\r\n        tag,\r\n        type: newChild.type,\r\n        props: newChild.props,\r\n        children: newChild.children,\r\n        stateNode: null,\r\n        parent: currentFiber,\r\n        effectTag: PLACEMENT,\r\n        updaterQueue: new UpdaterQueue(),\r\n        nextEffect: null\r\n      }\r\n    } else if(oldFiber){\r\n      oldFiber.effectTag = DELETION\r\n      deletions.push(oldFiber)\r\n    }\r\n\r\n    if(oldFiber) {\r\n      oldFiber = oldFiber.sibling\r\n    }\r\n\r\n    if(childrenIndex === 1) {\r\n      currentFiber.child = newFiber\r\n    } else {\r\n      prevSibling.sibling = newFiber\r\n    }\r\n    prevSibling = newFiber\r\n  }\r\n}\r\n\r\nfunction createDOM(currentFiber : any) {\r\n  const { tag } = currentFiber\r\n  if(tag === TAG_TEXT) {\r\n    return document.createTextNode(currentFiber.children)\r\n  } else if(tag == TAG_ELEMENT) {\r\n    const dom = document.createElement(currentFiber.type)\r\n    updateDOM(dom,{},currentFiber.props)\r\n    return dom\r\n  }\r\n}\r\n\r\nfunction updateDOM(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  setProps(dom,oldProps,newProps)\r\n}\r\n\r\nfunction setProps(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  for(let key in oldProps) {\r\n    if(hasOwnProperty(newProps,key)) {\r\n      dom.removeAttribute(key)\r\n    }\r\n  }\r\n  for(let key in newProps) {\r\n    setProp(dom,key,newProps[key])\r\n  }\r\n}\r\n\r\nfunction setProp(dom : HTMLElement,key : string,value : any) {\r\n  if(/^on/.test(key)) {\r\n    dom[key.toLowerCase()] = value\r\n  } else if(key === \"className\") {\r\n    dom.className = value\r\n  } else if(key === \"style\") {\r\n    for(let styleName in value) {\r\n      dom.style[styleName] = value[styleName]\r\n    }\r\n  } else {\r\n    dom.setAttribute(key,value)\r\n  }\r\n}\r\n\r\nfunction scheduleRoot(rootFiber? : any) {\r\n  if(currentRoot && currentRoot.alternate) {\r\n    workInProgressRoot = currentRoot.alternate\r\n    workInProgressRoot.alternate = currentRoot\r\n    if(rootFiber) {\r\n      workInProgressRoot.props = rootFiber.props\r\n      workInProgressRoot.children = rootFiber.children\r\n    }\r\n  } else if(currentRoot) {\r\n    if(rootFiber) {\r\n      rootFiber.alternate = currentRoot\r\n      workInProgressRoot = rootFiber\r\n    } else {\r\n      workInProgressRoot = {\r\n        ...currentRoot,\r\n        alternate: currentRoot\r\n      }\r\n    }\r\n  } else {\r\n    workInProgressRoot = rootFiber\r\n  }\r\n  (workInProgressRoot.firstEffect =\r\n  workInProgressRoot.lastEffect = \r\n  workInProgressRoot.nextEffect = null)\r\n  nextUnitOfWork = workInProgressRoot\r\n}\r\n\r\nexport {\r\n  scheduleRoot,\r\n}", "import { scheduleRoot } from \"../react/src/scheduler\"\r\nimport { TAG_ROOT } from \"../types\"\r\n\r\nfunction render(element : any, container : Node) {\r\n  const rootFiber = {\r\n    tag: TAG_ROOT,\r\n    stateNode : container,\r\n    props: {\r\n    },\r\n    children: [element]\r\n  }\r\n  scheduleRoot(rootFiber)\r\n}\r\n\r\nexport {\r\n  render,\r\n}"],
  "mappings": "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",
  "names": []
}
