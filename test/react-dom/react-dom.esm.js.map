{
  "version": 3,
  "sources": ["../../packages/shared/src/utils.ts", "../../packages/types/src/nodeType.ts", "../../packages/types/src/effectType.ts", "../../packages/react/src/schedule.ts", "../../packages/react-dom/index.ts"],
  "sourcesContent": ["function isObject(value : any) : boolean {\r\n  return typeof value === 'object'\r\n}\r\n\r\nfunction isNumber(value : any) : boolean {\r\n  return !isNaN(value) && typeof value === 'number'\r\n}\r\n\r\nfunction isString(value : any) : boolean {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isBoolean(value : any) : boolean {\r\n  return typeof value === 'boolean'\r\n}\r\n\r\nfunction isArray(value : any) : boolean {\r\n  return Array.isArray(value)\r\n}\r\n\r\nfunction isFunction(value : any) : boolean {\r\n  return typeof value === 'function'\r\n}\r\n\r\nfunction toUppercaseStart(value : string) : string {\r\n  if(value) {\r\n    value = value.replace(value[0],value[0].toUpperCase());\r\n  }\r\n  return value\r\n}\r\n\r\nfunction isUppercaseStart(value : string) : boolean {\r\n  if(value) {\r\n    const c = value.charAt(0)\r\n    if(c >= \"A\" && c <= \"Z\") {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction hasOwnProperty(value : any,key : any) : boolean {\r\n  return Object.prototype.hasOwnProperty.call(value,key)\r\n} \r\n\r\nfunction removeExtraSpaces(value : string) : string {\r\n  return value.replace(/[\\s]+/g,\"\")\r\n}\r\n\r\nfunction getLongestIncreasingSequence(arr : Array<number>) : Array<number> {\r\n  const len = arr.length\r\n  const result = [0]\r\n  const traceBack = new Array(len)\r\n  let startIndex\r\n  let endIndex\r\n  let middleIndex\r\n  let resultLastIndex;\r\n  for(let i = 0; i < len; i++) {\r\n    let item = arr[i]\r\n    if(item === 0) {\r\n      continue\r\n    }\r\n    resultLastIndex = result[result.length - 1]\r\n    if(arr[resultLastIndex] < item) {\r\n      result.push(i)\r\n      traceBack[i] = resultLastIndex\r\n      continue\r\n    }\r\n\r\n    startIndex = 0\r\n    endIndex = result.length - 1\r\n    while(startIndex < endIndex) {\r\n      middleIndex = ((startIndex + endIndex) / 2) | 0\r\n      if(arr[result[middleIndex]] < item) {\r\n        startIndex = middleIndex  + 1\r\n      } else {\r\n        endIndex = middleIndex\r\n      }\r\n    }\r\n\r\n    if(arr[result[endIndex]] > item) {\r\n      result[endIndex] = i\r\n      traceBack[i] = result[endIndex - 1]\r\n    }\r\n  }\r\n\r\n  let i = result.length\r\n  let last = result[i - 1]\r\n  while(i-- > 0) {\r\n    result[i] = last\r\n    last = traceBack[last]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction invokeFunctions(funs : Array<Function>) {\r\n  for(let i = 0; i < funs.length; i++) {\r\n    const fun = funs[i]\r\n    fun()\r\n  }\r\n}\r\n\r\nfunction onlyOne(items : any) {\r\n  return isArray(items) ? items[0] : items\r\n}\r\n\r\nfunction flatten(array : Array<any>) {\r\n  const flatted : Array<any> = []\r\n  function flat(items : Array<any>) {\r\n    items.forEach(item => {\r\n      if(isArray(item)) {\r\n        flat(item)\r\n      } else {\r\n        flatted.push(item)\r\n      }\r\n    })\r\n  }\r\n  flat(array)\r\n  return flatted\r\n}\r\n\r\nexport {\r\n  isObject,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  isArray,\r\n  isFunction,\r\n  hasOwnProperty,\r\n  toUppercaseStart,\r\n  isUppercaseStart,\r\n  removeExtraSpaces,\r\n  getLongestIncreasingSequence,\r\n  invokeFunctions,\r\n  onlyOne,\r\n  flatten,\r\n}", "const TEXT = Symbol.for(\"TEXT\")\r\n\r\n\r\nconst TAG_ROOT = Symbol.for(\"TAG_ROOT\")\r\nconst TAG_ELEMENT = Symbol.for(\"TAG_ELEMENT\")\r\nconst TAG_TEXT = Symbol.for(\"TAG_TEXT\")\r\nconst TAG_COMMENT = Symbol.for(\"TAG_COMMENT\")\r\n\r\nexport {\r\n  TEXT,\r\n\r\n  TAG_ROOT,\r\n  TAG_ELEMENT,\r\n  TAG_TEXT,\r\n  TAG_COMMENT,\r\n}", "const PLACEMENT = Symbol.for(\"PLACEMENT\")\r\nconst UPDATE = Symbol.for(\"PLACEMENT\")\r\nconst DELETION = Symbol.for(\"PLACEMENT\")\r\n\r\nexport {\r\n  PLACEMENT,\r\n  UPDATE,\r\n  DELETION,\r\n}", "import { hasOwnProperty, isString } from \"../../shared\"\r\nimport { PLACEMENT, TAG_COMMENT, TAG_ELEMENT, TAG_ROOT, TAG_TEXT, TEXT } from \"../../types\"\r\n\r\nlet workInProgressRoot : any = null\r\nlet nextUnitOfWork : any = null\r\nlet currentRoot : any = null\r\n\r\nfunction startWork() {\r\n  requestIdleCallback(workLoop,{ timeout: 500 })\r\n}\r\nstartWork()\r\n\r\nfunction workLoop(deadline : any) {\r\n  let shouldYield = false\r\n  while(nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\r\n    shouldYield = deadline.timeRemaining() < 1\r\n  }\r\n  if(!nextUnitOfWork && workInProgressRoot) {\r\n    commitRoot()\r\n  }\r\n  startWork()\r\n}\r\n\r\nfunction commitRoot() {\r\n  let currentFiber = workInProgressRoot.firstEffect\r\n  while(currentFiber) {\r\n    commitWork(currentFiber)\r\n    currentFiber = currentFiber.nextEffect\r\n  }\r\n  currentRoot = workInProgressRoot\r\n  workInProgressRoot = null\r\n}\r\n\r\nfunction commitWork(currentFiber : any) {\r\n  if(!currentFiber) return\r\n  const parentFiber = currentFiber.parent\r\n  const parentNode = parentFiber.stateNode\r\n  if(currentFiber.effectTag === PLACEMENT) {\r\n    parentNode.appendChild(currentFiber.stateNode)\r\n  }\r\n  currentFiber.effectTag = null\r\n}\r\n\r\nfunction performUnitOfWork(currentFiber : any) {\r\n  beginWork(currentFiber)\r\n  if(currentFiber.child) {\r\n    return currentFiber.child\r\n  }\r\n  while(currentFiber) {\r\n    completeUnitOfWork(currentFiber)\r\n    if(currentFiber.sibling) {\r\n      return currentFiber.sibling\r\n    }\r\n    currentFiber = currentFiber.parent\r\n  }\r\n}\r\n\r\nfunction completeUnitOfWork(currentFiber : any) {\r\n  const { parent: parentFiber,effectTag } = currentFiber\r\n  if(parentFiber) {\r\n    if(!parentFiber.firstEffect) {\r\n      parentFiber.firstEffect = currentFiber.firstEffect\r\n    }\r\n    if(currentFiber.lastEffect) {\r\n      if(parentFiber.lastEffect) {\r\n        parentFiber.lastEffect.nextEffect = currentFiber.firstEffect\r\n      }\r\n      parentFiber.lastEffect = currentFiber.lastEffect\r\n    }\r\n    if(effectTag) {\r\n      if(parentFiber.lastEffect) {\r\n        parentFiber.lastEffect.nextEffect = currentFiber\r\n      } else {\r\n        parentFiber.firstEffect = currentFiber\r\n      }\r\n      parentFiber.lastEffect = currentFiber\r\n    }\r\n  }\r\n}\r\n\r\nfunction beginWork(currentFiber : any) {\r\n  const { tag } = currentFiber\r\n  if(tag === TAG_ROOT) {\r\n    updateHostRoot(currentFiber)\r\n  } else if(tag === TAG_TEXT) {\r\n    updateHostText(currentFiber)\r\n  } else if(tag === TAG_ELEMENT) {\r\n    updateHostElement(currentFiber)\r\n  }\r\n}\r\n\r\nfunction updateHostElement(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = createDOM(currentFiber)\r\n  } \r\n  const children = currentFiber.children\r\n  reconcileChildren(currentFiber,children)\r\n}\r\n\r\nfunction updateHostText(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = createDOM(currentFiber)\r\n  }\r\n}\r\n\r\nfunction updateHostRoot(currentFiber : any) {\r\n  const children = currentFiber.children\r\n  reconcileChildren(currentFiber,children)\r\n}\r\n\r\nfunction reconcileChildren(currentFiber : any,children : Array<any>) {\r\n  let childrenIndex = 0\r\n  let prevSibling : any\r\n  while(childrenIndex < children.length) {\r\n    const child = children[childrenIndex++]\r\n    let tag : Symbol\r\n    if(child.type === TEXT) {\r\n      tag = TAG_TEXT\r\n    } else if(isString(child.type)) {\r\n      tag = TAG_ELEMENT\r\n    } else {\r\n      tag = TAG_COMMENT\r\n    }\r\n    const childFiber = {\r\n      tag,\r\n      type: child.type,\r\n      props: child.props,\r\n      children: child.children,\r\n      stateNode: null,\r\n      parent: currentFiber,\r\n      effectTag: PLACEMENT,\r\n      nextEffect: null\r\n    }\r\n    if(childrenIndex === 1) {\r\n      currentFiber.child = childFiber\r\n    } else {\r\n      prevSibling.sibling = childFiber\r\n    }\r\n    prevSibling = childFiber\r\n  }\r\n}\r\n\r\nfunction createDOM(currentFiber : any) {\r\n  const { tag } = currentFiber\r\n  if(tag === TAG_TEXT) {\r\n    return document.createTextNode(currentFiber.children)\r\n  } else if(tag == TAG_ELEMENT) {\r\n    const dom = document.createElement(currentFiber.type)\r\n    updateDOM(dom,{},currentFiber.props)\r\n    return dom\r\n  }\r\n}\r\n\r\nfunction updateDOM(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  setProps(dom,oldProps,newProps)\r\n}\r\n\r\nfunction setProps(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  for(let key in oldProps) {\r\n    if(hasOwnProperty(newProps,key)) {\r\n      dom.removeAttribute(key)\r\n    }\r\n  }\r\n  for(let key in newProps) {\r\n    setProp(dom,key,newProps[key])\r\n  }\r\n}\r\n\r\nfunction setProp(dom : HTMLElement,key : string,value : any) {\r\n  if(/^on/.test(key)) {\r\n    dom[key.toLowerCase()] = value\r\n  } else if(key === \"className\") {\r\n    dom.className = value\r\n  } else if(key === \"style\") {\r\n    for(let styleName in value) {\r\n      dom.style[styleName] = value[styleName]\r\n    }\r\n  } else {\r\n    dom.setAttribute(key,value)\r\n  }\r\n}\r\n\r\nfunction scheduleRoot(rootFiber : any) {\r\n  workInProgressRoot = rootFiber\r\n  nextUnitOfWork = rootFiber\r\n}\r\n\r\nexport {\r\n  scheduleRoot,\r\n}", "import { scheduleRoot } from \"../react/src/schedule\"\r\nimport { TAG_ROOT } from \"../types\"\r\n\r\nfunction render(element : any, container : Node) {\r\n  const rootFiber = {\r\n    tag: TAG_ROOT,\r\n    stateNode : container,\r\n    props: {\r\n    },\r\n    children: [element]\r\n  }\r\n  scheduleRoot(rootFiber)\r\n}\r\n\r\nexport {\r\n  render,\r\n}"],
  "mappings": "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",
  "names": []
}
