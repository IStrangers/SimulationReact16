{
  "version": 3,
  "sources": ["../../packages/shared/src/utils.ts", "../../packages/react/src/updater.ts", "../../packages/react/src/event.ts", "../../packages/types/src/nodeType.ts", "../../packages/react/src/vdom.ts", "../../packages/react-dom/index.ts"],
  "sourcesContent": ["function isObject(value : any) : boolean {\r\n  return typeof value === 'object'\r\n}\r\n\r\nfunction isNumber(value : any) : boolean {\r\n  return !isNaN(value) && typeof value === 'number'\r\n}\r\n\r\nfunction isString(value : any) : boolean {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isBoolean(value : any) : boolean {\r\n  return typeof value === 'boolean'\r\n}\r\n\r\nfunction isArray(value : any) : boolean {\r\n  return Array.isArray(value)\r\n}\r\n\r\nfunction isFunction(value : any) : boolean {\r\n  return typeof value === 'function'\r\n}\r\n\r\nfunction toUppercaseStart(value : string) : string {\r\n  if(value) {\r\n    value = value.replace(value[0],value[0].toUpperCase());\r\n  }\r\n  return value\r\n}\r\n\r\nfunction isUppercaseStart(value : string) : boolean {\r\n  if(value) {\r\n    const c = value.charAt(0)\r\n    if(c >= \"A\" && c <= \"Z\") {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction hasOwnProperty(value : any,key : any) : boolean {\r\n  return Object.prototype.hasOwnProperty.call(value,key)\r\n} \r\n\r\nfunction removeExtraSpaces(value : string) : string {\r\n  return value.replace(/[\\s]+/g,\"\")\r\n}\r\n\r\nfunction getLongestIncreasingSequence(arr : Array<number>) : Array<number> {\r\n  const len = arr.length\r\n  const result = [0]\r\n  const traceBack = new Array(len)\r\n  let startIndex\r\n  let endIndex\r\n  let middleIndex\r\n  let resultLastIndex;\r\n  for(let i = 0; i < len; i++) {\r\n    let item = arr[i]\r\n    if(item === 0) {\r\n      continue\r\n    }\r\n    resultLastIndex = result[result.length - 1]\r\n    if(arr[resultLastIndex] < item) {\r\n      result.push(i)\r\n      traceBack[i] = resultLastIndex\r\n      continue\r\n    }\r\n\r\n    startIndex = 0\r\n    endIndex = result.length - 1\r\n    while(startIndex < endIndex) {\r\n      middleIndex = ((startIndex + endIndex) / 2) | 0\r\n      if(arr[result[middleIndex]] < item) {\r\n        startIndex = middleIndex  + 1\r\n      } else {\r\n        endIndex = middleIndex\r\n      }\r\n    }\r\n\r\n    if(arr[result[endIndex]] > item) {\r\n      result[endIndex] = i\r\n      traceBack[i] = result[endIndex - 1]\r\n    }\r\n  }\r\n\r\n  let i = result.length\r\n  let last = result[i - 1]\r\n  while(i-- > 0) {\r\n    result[i] = last\r\n    last = traceBack[last]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction invokeFunctions(funs : Array<Function>) {\r\n  for(let i = 0; i < funs.length; i++) {\r\n    const fun = funs[i]\r\n    fun()\r\n  }\r\n}\r\n\r\nfunction onlyOne(items : any) {\r\n  return isArray(items) ? items[0] : items\r\n}\r\n\r\nfunction flatten(array : Array<any>) {\r\n  const flatted : Array<any> = []\r\n  function flat(items : Array<any>) {\r\n    items.forEach(item => {\r\n      if(isArray(item)) {\r\n        flat(item)\r\n      } else {\r\n        flatted.push(item)\r\n      }\r\n    })\r\n  }\r\n  flat(array)\r\n  return flatted\r\n}\r\n\r\nexport {\r\n  isObject,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  isArray,\r\n  isFunction,\r\n  hasOwnProperty,\r\n  toUppercaseStart,\r\n  isUppercaseStart,\r\n  removeExtraSpaces,\r\n  getLongestIncreasingSequence,\r\n  invokeFunctions,\r\n  onlyOne,\r\n  flatten,\r\n}", "import { isFunction } from \"../../shared\"\r\nimport { Component } from \"./component\"\r\n\r\nclass UpdaterQueue {\r\n\r\n  public updaters : Array<Updater>  = []\r\n  public isPending : boolean = false\r\n\r\n  add(updater : Updater) {\r\n    this.updaters.push(updater)\r\n  }\r\n\r\n  batchUpdate() {\r\n    let updater \r\n    while(updater = this.updaters.pop()) {\r\n      updater.updateComponent()\r\n    }\r\n    this.isPending = false\r\n  }\r\n  \r\n}\r\n\r\nconst updaterQueue = new UpdaterQueue()\r\n\r\nclass Updater {\r\n  \r\n  public pendingState : Array<any>\r\n  public nextProps : any\r\n\r\n  constructor(public componentInstance : Component) {\r\n    this.pendingState = []\r\n    this.nextProps = null\r\n  }\r\n\r\n  addState(partialState : any) {\r\n    this.pendingState.push(partialState)\r\n    this.emitUpdate(null)\r\n  }\r\n\r\n  emitUpdate(nextProps : any) {\r\n    this.nextProps = nextProps\r\n    if(nextProps || !updaterQueue.isPending) {\r\n      this.updateComponent()\r\n    } else {\r\n      updaterQueue.add(this)\r\n    }\r\n  }\r\n\r\n  updateComponent() {\r\n    if(this.nextProps || this.pendingState.length > 0) {\r\n      shouldUpdate(this.componentInstance,this.nextProps,this.getState())\r\n    }\r\n  }\r\n\r\n  getState() {\r\n    let state\r\n    if(this.pendingState.length > 0) {\r\n      this.pendingState.forEach(nextState => {\r\n        if(isFunction(nextState)) {\r\n          state = {...this.componentInstance.state,...nextState.call(this.componentInstance,this.componentInstance.state)}\r\n        } else {\r\n          state = {...this.componentInstance.state,...nextState}\r\n        }\r\n      })\r\n    }\r\n    this.pendingState.length = 0\r\n    return state\r\n  }\r\n}\r\n\r\nfunction shouldUpdate(componentInstance : Component,nextProps : any,nextState : any) {\r\n  componentInstance.props = nextProps\r\n  componentInstance.state = nextState\r\n  if(!componentInstance.isOverMount || !componentInstance.shouldComponentUpdate(nextProps,nextState)) {\r\n    return false\r\n  }\r\n  componentInstance.forceUpdate()\r\n}\r\n\r\nfunction batchedUpdates(fn : Function) {\r\n  updaterQueue.isPending = true\r\n  fn()\r\n  updaterQueue.isPending = false\r\n  updaterQueue.batchUpdate()\r\n}\r\n\r\nexport {\r\n  updaterQueue,\r\n  Updater,\r\n  batchedUpdates,\r\n}", "import { updaterQueue } from \"./updater\"\r\nimport { isFunction } from \"../../shared/src/utils\"\r\n\r\nfunction addEventListener(dom : HTMLElement,eventType : string,listener : Function) {\r\n  eventType = eventType.toLowerCase()\r\n  const eventStore = dom[\"eventStore\"] || (dom[\"eventStore\"] = {})\r\n  eventStore[eventType] = listener\r\n  document.addEventListener(eventType.slice(2),dispatchEvent,false)\r\n}\r\n\r\nlet syntheticEvent : SyntheticEvent | null = null\r\nfunction dispatchEvent(event : Event) {\r\n  let { type,target } = event\r\n  const eventType = `on${type}`\r\n  syntheticEvent = getSyntheticEvent(event)\r\n  updaterQueue.isPending = true\r\n  while (target) {\r\n    const eventStore = target[\"eventStore\"]\r\n    const listener = eventStore && eventStore[eventType]\r\n    if(listener) {\r\n      listener.call(target,syntheticEvent)\r\n    }\r\n    target = target[\"parentNode\"]\r\n  }\r\n  for(let key in syntheticEvent) {\r\n    syntheticEvent[key] = undefined\r\n  }\r\n  updaterQueue.isPending = false\r\n  updaterQueue.batchUpdate()\r\n}\r\n\r\nclass SyntheticEvent {\r\n  persist() {\r\n    syntheticEvent = null\r\n  }\r\n}\r\nfunction getSyntheticEvent(nativeEvent : Event) {\r\n  if(!syntheticEvent) {\r\n    syntheticEvent = new SyntheticEvent()\r\n  }\r\n  syntheticEvent[\"nativeEvent\"] = nativeEvent\r\n  for(let key in nativeEvent) {\r\n    const value = nativeEvent[key]\r\n    if(isFunction(value)) {\r\n      syntheticEvent[key] = value.bind(nativeEvent)\r\n    } else {\r\n      syntheticEvent[key] = value\r\n    }\r\n  }\r\n  return syntheticEvent\r\n}\r\n\r\nexport {\r\n  addEventListener,\r\n}", "const TEXT = Symbol.for(\"TEXT\")\r\nconst ELEMENT = Symbol.for(\"ELEMENT\")\r\nconst CLASS_COMPONENT = Symbol.for(\"CLASS_COMPONENT\")\r\nconst FUNCTION_COMPONENT = Symbol.for(\"FUNCTION_COMPONENT\")\r\n\r\nexport {\r\n  TEXT,\r\n  ELEMENT,\r\n  CLASS_COMPONENT,\r\n  FUNCTION_COMPONENT,\r\n}", "import { flatten, hasOwnProperty, onlyOne } from \"../../shared\"\r\nimport { addEventListener } from \"./event\"\r\nimport { CLASS_COMPONENT, ELEMENT, FUNCTION_COMPONENT, TEXT } from \"../../types\"\r\nimport { Component } from \"./component\"\r\nimport { batchedUpdates } from \"./updater\"\r\n\r\nfunction ReactElement(nodeType : Symbol,type : any,key : any,ref : any,props : any,children : Array<any>) {\r\n  const element = {\r\n    nodeType,\r\n    type,\r\n    key,\r\n    ref,\r\n    props,\r\n    children\r\n  }\r\n  return element\r\n}\r\n\r\nfunction createDOM(element : any) : Node {\r\n  element = onlyOne(element)\r\n  let dom : Node\r\n  const { nodeType } = element\r\n  if(nodeType === TEXT) {\r\n    dom = document.createTextNode(element.content)\r\n  } else if(nodeType === ELEMENT){\r\n    dom = createNativeDOM(element)\r\n  } else if(nodeType === CLASS_COMPONENT){\r\n    dom = createClassComponentDOM(element)\r\n  } else if(nodeType === FUNCTION_COMPONENT){\r\n    dom = createFunctionComponentDOM(element)\r\n  } else {\r\n    dom = document.createComment(element.content ? element.content : \"\")\r\n  }\r\n  element.dom = dom\r\n  return dom\r\n}\r\n\r\nfunction createNativeDOM(element : any) : HTMLElement {\r\n  const { type,ref,props,children } = element\r\n  const dom = document.createElement(type)\r\n  ref && setRef(dom,ref)\r\n  props && setProps(dom,props)\r\n  children && createChildrenDOM(dom,children)\r\n  return dom\r\n}\r\n\r\nfunction setRef(current : Node | Component,ref : any) {\r\n  if(ref) {\r\n    ref.current = current\r\n  }\r\n}\r\n\r\nfunction createChildrenDOM(parentNode : Node,children : Array<any>) {\r\n  children && flatten(children).forEach((child,index) => {\r\n    child[\"mountIndex\"] = index\r\n    const childDOM = createDOM(child)\r\n    parentNode.appendChild(childDOM)\r\n  })\r\n}\r\n\r\nfunction setProps(dom : HTMLElement,props : any) {\r\n  for(let key in props) {\r\n    setProp(dom,key,props[key])\r\n  }\r\n}\r\n\r\nfunction setProp(dom : HTMLElement,key : string,value : any) {\r\n  if(/^on/.test(key)) {\r\n    addEventListener(dom,key,value)\r\n  } else if(key === \"className\") {\r\n    dom.className = value\r\n  } else if(key === \"style\") {\r\n    for(let styleName in value) {\r\n      dom.style[styleName] = value[styleName]\r\n    }\r\n  } else {\r\n    dom.setAttribute(key,value)\r\n  }\r\n}\r\n\r\nfunction createClassComponentDOM(element : any) {\r\n  const { type,ref,props } = element\r\n  const componentInstance = new type(props)\r\n  setContext(componentInstance,type)\r\n  setRef(componentInstance,ref)\r\n  componentInstance.componentWillMount()\r\n  const renderElement = componentInstance.render()\r\n  const dom = createDOM(renderElement)\r\n  renderElement.dom = dom\r\n  componentInstance.renderElement = renderElement\r\n  element.componentInstance = componentInstance\r\n  batchedUpdates(() => componentInstance.componentDidMount())\r\n  componentInstance.isOverMount = true\r\n  return dom\r\n}\r\n\r\nfunction setContext(componentInstance : Component,classType : any) {\r\n  if(classType.contextType) {\r\n    componentInstance.context = classType.contextType.Provider.value\r\n  }\r\n}\r\n\r\nfunction createFunctionComponentDOM(element : any) {\r\n  const { type,props } = element\r\n  const renderElement = type(props)\r\n  const dom = createDOM(renderElement)\r\n  renderElement.dom = dom\r\n  element.renderElement = renderElement\r\n  return dom\r\n}\r\n\r\n\r\n\r\nfunction compareTwoElements(oldRenderElement : any,newRenderElement : any) {\r\n  oldRenderElement = onlyOne(oldRenderElement)\r\n  newRenderElement = onlyOne(newRenderElement)\r\n  const currentDOM = oldRenderElement.dom\r\n  let currentElement = oldRenderElement\r\n  if(newRenderElement === null) {\r\n    currentDOM.parentNode.removeChild(currentDOM)\r\n  } else if(oldRenderElement.type !== newRenderElement.type) {\r\n    const newDOM = createDOM(newRenderElement)\r\n    currentDOM.parentNode.replaceChild(newDOM,currentDOM)\r\n    currentElement = newRenderElement\r\n  } else {\r\n    updateElement(oldRenderElement,newRenderElement)\r\n  }\r\n  return currentElement\r\n}\r\n\r\nfunction updateElement(oldElement : any,newElement : any) {\r\n  const currentDOM = newElement.dom = oldElement.dom\r\n  if(oldElement.nodeType === TEXT && newElement.nodeType === TEXT && oldElement.content !== newElement.content) {\r\n    currentDOM.textContent = newElement.content\r\n  } else if(oldElement.nodeType === ELEMENT) {\r\n    updateProps(currentDOM,oldElement.props,newElement.props)\r\n    updateChildrenElement(currentDOM,oldElement.children,newElement.children)\r\n    oldElement.props = newElement.props\r\n  } else if(oldElement.nodeType === CLASS_COMPONENT) {\r\n    updateClassComponent(oldElement,newElement)\r\n  } else if(oldElement.nodeType === FUNCTION_COMPONENT) {\r\n    updateFunctionComponent(oldElement,newElement)\r\n  }\r\n}\r\n\r\nfunction updateProps(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  for(let key in oldProps) {\r\n    if(hasOwnProperty(newProps,key)) {\r\n      dom.removeAttribute(key)\r\n    }\r\n  }\r\n  setProps(dom,newProps)\r\n}\r\n\r\nlet updateDepth = 0\r\nconst diffQueue : Array<any> = []\r\nfunction updateChildrenElement(dom : HTMLElement,oldChildren : Array<any>,newChildren : Array<any>) {\r\n  updateDepth++\r\n  diff(dom,oldChildren,newChildren)\r\n  updateDepth--\r\n  if(updateDepth === 0) {\r\n    patch()\r\n  }\r\n}\r\n\r\nfunction diff(dom : HTMLElement,oldChildren : Array<any>,newChildren : Array<any>) {\r\n  const oldChildrenElementsMap = getChildrenElementsMap(oldChildren)\r\n  const newChildrenElementsMap = getNewChildrenElementsMap(oldChildrenElementsMap,newChildren)\r\n  let lastIndex = 0\r\n  for(let i = 0; i < newChildren.length; i++) {\r\n    const newElement = newChildren[i]\r\n    if(!newElement) {\r\n      const oldElement = oldChildrenElementsMap[i.toString()]\r\n      if(oldElement.componentInstance) {\r\n        oldElement.componentInstance.componentWillUnmount()\r\n      }\r\n      continue\r\n    }\r\n    const newKey = newElement.key || i.toString()\r\n    const oldElement = oldChildrenElementsMap[newKey]\r\n    if(oldElement === newElement) {\r\n      const mountIndex = oldElement.mountIndex\r\n      if(mountIndex < lastIndex) {\r\n        diffQueue.push({\r\n          parentNode: dom,\r\n          type: \"MOVE\",\r\n          fromIndex: mountIndex,\r\n          toIndex: i\r\n        })\r\n      }\r\n      lastIndex = Math.max(mountIndex,lastIndex)\r\n    } else {\r\n      diffQueue.push({\r\n        parentNode: dom,\r\n        type: \"INSERT\",\r\n        toIndex: i,\r\n        dom: createDOM(newElement)\r\n      })\r\n    }\r\n    newElement.mountIndex = i\r\n  }\r\n  for(let oldKey in oldChildrenElementsMap) {\r\n    if(newChildrenElementsMap.hasOwnProperty(oldKey)) {\r\n      const oldElement = oldChildrenElementsMap[oldKey]\r\n      diffQueue.push({\r\n        parentNode: dom,\r\n        type: \"REMOVE\",\r\n        fromIndex: oldElement.mountIndex\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nfunction patch() {\r\n  const deleteMap = {}\r\n  const deleteChildren = []\r\n  for(let i = 0; i < diffQueue.length; i++) {\r\n    const { type,fromIndex,parentNode } = diffQueue[i]\r\n    if(type === \"MOVE\" || type === \"REMOVE\") {\r\n      const oldElement = parentNode.children[fromIndex]\r\n      deleteMap[fromIndex] = oldElement\r\n      deleteChildren.push(oldElement)\r\n    }\r\n  }\r\n  deleteChildren.forEach(child => {\r\n    child.parentNode.removeChild(child)\r\n  })\r\n  for(let i = 0; i < diffQueue.length; i++) {\r\n    const { type,fromIndex,toIndex,parentNode,dom } = diffQueue[i]\r\n    if(type === \"MOVE\") {\r\n      insertChildAt(parentNode,deleteMap[fromIndex],toIndex)\r\n    } else if(type === \"INSERT\") {\r\n      insertChildAt(parentNode,dom,toIndex)\r\n    }\r\n  }\r\n  diffQueue.length = 0\r\n}\r\n\r\nfunction insertChildAt(parentNode : HTMLElement,child : Node,index : number) {\r\n  const oldChild = parentNode.children[index]\r\n  oldChild ? parentNode.insertBefore(child,oldChild) : parentNode.appendChild(child)\r\n}\r\n\r\nfunction getChildrenElementsMap(oldChildren : Array<any>) {\r\n  const oldChildrenElementsMap = {}\r\n  for(let i = 0; i < oldChildren.length; i++) {\r\n    const oldKey = oldChildren[i].key || i.toString()\r\n    oldChildrenElementsMap[oldKey] = oldChildren[i]\r\n  }\r\n  return oldChildrenElementsMap\r\n}\r\n\r\nfunction getNewChildrenElementsMap(oldChildrenElementsMap : any,newChildren : Array<any>) {\r\n  const newChildrenElementsMap = {}\r\n  for(let i = 0; i < newChildren.length; i++) {\r\n    const newElement = newChildren[i]\r\n    if(!newElement) {\r\n      continue\r\n    }\r\n    const newKey = newElement.key || i.toString()\r\n    const oldElement = oldChildrenElementsMap[newKey]\r\n    if(canDeepCompare(oldElement,newElement)) {\r\n      updateElement(oldElement,newElement)\r\n      newChildren[i] = oldElement\r\n    }\r\n    newChildrenElementsMap[newKey] = newChildren[i]\r\n  }\r\n  return newChildrenElementsMap\r\n}\r\n\r\nfunction canDeepCompare(oldElement : any,newElement :any) {\r\n  if(!!oldElement && !!newElement) {\r\n    return oldElement.type === newElement.type\r\n  }\r\n  return false\r\n}\r\n\r\nfunction updateClassComponent(oldElement : any,newElement : any) {\r\n  const componentInstance = newElement.componentInstance = oldElement.componentInstance\r\n  setContext(componentInstance,oldElement.type)\r\n  const nextProps = newElement.props\r\n  componentInstance.componentWillReceiveProps(nextProps)\r\n  componentInstance.state = newElement.type.getDerivedStateFromProps(nextProps,componentInstance.state)\r\n  componentInstance.$updater.emitUpdate(nextProps)\r\n}\r\n\r\nfunction updateFunctionComponent(oldElement : any,newElement : any) {\r\n  const oldRenderElement = oldElement.renderElement\r\n  const newRenderElement = newElement.type(newElement.props)\r\n  const currentElement = compareTwoElements(oldRenderElement,newRenderElement)\r\n  newElement.renderElement = currentElement\r\n}\r\n\r\nexport {\r\n  ReactElement,\r\n  createDOM,\r\n  createNativeDOM,\r\n  createChildrenDOM,\r\n  setProps,\r\n  setProp,\r\n  setRef,\r\n  createClassComponentDOM,\r\n  createFunctionComponentDOM,\r\n  compareTwoElements,\r\n  updateElement,\r\n  updateProps,\r\n  updateChildrenElement,\r\n  updateClassComponent,\r\n  updateFunctionComponent,\r\n}", "import { createDOM } from \"../react/src/vdom\"\r\n\r\nfunction render(element : any,container : Node) {\r\n  const dom = createDOM(element)\r\n  container.appendChild(dom)\r\n}\r\n\r\nexport {\r\n  render\r\n}"],
  "mappings": "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",
  "names": []
}
