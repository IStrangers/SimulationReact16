{
  "version": 3,
  "sources": ["../../packages/react-dom/index.ts", "../../packages/shared/src/utils.ts", "../../packages/react/src/updater.ts", "../../packages/react/src/event.ts", "../../packages/types/src/nodeType.ts", "../../packages/react/src/vdom.ts"],
  "sourcesContent": ["import { createDOM } from \"../react/src/vdom\"\r\n\r\nfunction render(element : any,container : Node) {\r\n  const dom = createDOM(element)\r\n  container.appendChild(dom)\r\n}\r\n\r\nexport {\r\n  render\r\n}", "function isObject(value : any) : boolean {\r\n  return typeof value === 'object'\r\n}\r\n\r\nfunction isNumber(value : any) : boolean {\r\n  return !isNaN(value) && typeof value === 'number'\r\n}\r\n\r\nfunction isString(value : any) : boolean {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isBoolean(value : any) : boolean {\r\n  return typeof value === 'boolean'\r\n}\r\n\r\nfunction isArray(value : any) : boolean {\r\n  return Array.isArray(value)\r\n}\r\n\r\nfunction isFunction(value : any) : boolean {\r\n  return typeof value === 'function'\r\n}\r\n\r\nfunction toUppercaseStart(value : string) : string {\r\n  if(value) {\r\n    value = value.replace(value[0],value[0].toUpperCase());\r\n  }\r\n  return value\r\n}\r\n\r\nfunction isUppercaseStart(value : string) : boolean {\r\n  if(value) {\r\n    const c = value.charAt(0)\r\n    if(c >= \"A\" && c <= \"Z\") {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction hasOwnProperty(value : any,key : any) : boolean {\r\n  return Object.prototype.hasOwnProperty.call(value,key)\r\n} \r\n\r\nfunction removeExtraSpaces(value : string) : string {\r\n  return value.replace(/[\\s]+/g,\"\")\r\n}\r\n\r\nfunction getLongestIncreasingSequence(arr : Array<number>) : Array<number> {\r\n  const len = arr.length\r\n  const result = [0]\r\n  const traceBack = new Array(len)\r\n  let startIndex\r\n  let endIndex\r\n  let middleIndex\r\n  let resultLastIndex;\r\n  for(let i = 0; i < len; i++) {\r\n    let item = arr[i]\r\n    if(item === 0) {\r\n      continue\r\n    }\r\n    resultLastIndex = result[result.length - 1]\r\n    if(arr[resultLastIndex] < item) {\r\n      result.push(i)\r\n      traceBack[i] = resultLastIndex\r\n      continue\r\n    }\r\n\r\n    startIndex = 0\r\n    endIndex = result.length - 1\r\n    while(startIndex < endIndex) {\r\n      middleIndex = ((startIndex + endIndex) / 2) | 0\r\n      if(arr[result[middleIndex]] < item) {\r\n        startIndex = middleIndex  + 1\r\n      } else {\r\n        endIndex = middleIndex\r\n      }\r\n    }\r\n\r\n    if(arr[result[endIndex]] > item) {\r\n      result[endIndex] = i\r\n      traceBack[i] = result[endIndex - 1]\r\n    }\r\n  }\r\n\r\n  let i = result.length\r\n  let last = result[i - 1]\r\n  while(i-- > 0) {\r\n    result[i] = last\r\n    last = traceBack[last]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction invokeFunctions(funs : Array<Function>) {\r\n  for(let i = 0; i < funs.length; i++) {\r\n    const fun = funs[i]\r\n    fun()\r\n  }\r\n}\r\n\r\nfunction onlyOne(items : any) {\r\n  return isArray(items) ? items[0] : items\r\n}\r\n\r\nfunction flatten(array : Array<any>) {\r\n  const flatted : Array<any> = []\r\n  function flat(items : Array<any>) {\r\n    items.forEach(item => {\r\n      if(isArray(item)) {\r\n        flat(item)\r\n      } else {\r\n        flatted.push(item)\r\n      }\r\n    })\r\n  }\r\n  flat(array)\r\n  return flatted\r\n}\r\n\r\nexport {\r\n  isObject,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  isArray,\r\n  isFunction,\r\n  hasOwnProperty,\r\n  toUppercaseStart,\r\n  isUppercaseStart,\r\n  removeExtraSpaces,\r\n  getLongestIncreasingSequence,\r\n  invokeFunctions,\r\n  onlyOne,\r\n  flatten,\r\n}", "import { isFunction } from \"../../shared\"\r\nimport { Component } from \"./component\"\r\n\r\nclass UpdaterQueue {\r\n\r\n  public updaters : Array<Updater>  = []\r\n  public isPending : boolean = false\r\n\r\n  add(updater : Updater) {\r\n    this.updaters.push(updater)\r\n  }\r\n\r\n  batchUpdate() {\r\n    let updater \r\n    while(updater = this.updaters.pop()) {\r\n      updater.updateComponent()\r\n    }\r\n    this.isPending = false\r\n  }\r\n  \r\n}\r\n\r\nconst updaterQueue = new UpdaterQueue()\r\n\r\nclass Updater {\r\n  \r\n  public pendingState : Array<any>\r\n  public nextProps : any\r\n\r\n  constructor(public componentInstance : Component) {\r\n    this.pendingState = []\r\n    this.nextProps = null\r\n  }\r\n\r\n  addState(partialState : any) {\r\n    this.pendingState.push(partialState)\r\n    this.emitUpdate(null)\r\n  }\r\n\r\n  emitUpdate(nextProps : any) {\r\n    this.nextProps = nextProps\r\n    if(nextProps || !updaterQueue.isPending) {\r\n      this.updateComponent()\r\n    } else {\r\n      updaterQueue.add(this)\r\n    }\r\n  }\r\n\r\n  updateComponent() {\r\n    if(this.nextProps || this.pendingState.length > 0) {\r\n      shouldUpdate(this.componentInstance,this.nextProps,this.getState())\r\n    }\r\n  }\r\n\r\n  getState() {\r\n    let state\r\n    if(this.pendingState.length > 0) {\r\n      this.pendingState.forEach(nextState => {\r\n        if(isFunction(nextState)) {\r\n          state = {...this.componentInstance.state,...nextState.call(this.componentInstance,this.componentInstance.state)}\r\n        } else {\r\n          state = {...this.componentInstance.state,...nextState}\r\n        }\r\n      })\r\n    }\r\n    this.pendingState.length = 0\r\n    return state\r\n  }\r\n}\r\n\r\nfunction shouldUpdate(componentInstance : Component,nextProps : any,nextState : any) {\r\n  componentInstance.props = nextProps\r\n  componentInstance.state = nextState\r\n  if(!componentInstance.isOverMount || !componentInstance.shouldComponentUpdate(nextProps,nextState)) {\r\n    return false\r\n  }\r\n  componentInstance.forceUpdate()\r\n}\r\n\r\nfunction batchedUpdates(fn : Function) {\r\n  updaterQueue.isPending = true\r\n  fn()\r\n  updaterQueue.isPending = false\r\n  updaterQueue.batchUpdate()\r\n}\r\n\r\nexport {\r\n  updaterQueue,\r\n  Updater,\r\n  batchedUpdates,\r\n}", "import { updaterQueue } from \"./updater\"\r\nimport { isFunction } from \"../../shared/src/utils\"\r\n\r\nfunction addEventListener(dom : HTMLElement,eventType : string,listener : Function) {\r\n  eventType = eventType.toLowerCase()\r\n  const eventStore = dom[\"eventStore\"] || (dom[\"eventStore\"] = {})\r\n  eventStore[eventType] = listener\r\n  document.addEventListener(eventType.slice(2),dispatchEvent,false)\r\n}\r\n\r\nlet syntheticEvent : SyntheticEvent | null = null\r\nfunction dispatchEvent(event : Event) {\r\n  let { type,target } = event\r\n  const eventType = `on${type}`\r\n  syntheticEvent = getSyntheticEvent(event)\r\n  updaterQueue.isPending = true\r\n  while (target) {\r\n    const eventStore = target[\"eventStore\"]\r\n    const listener = eventStore && eventStore[eventType]\r\n    if(listener) {\r\n      listener.call(target,syntheticEvent)\r\n    }\r\n    target = target[\"parentNode\"]\r\n  }\r\n  for(let key in syntheticEvent) {\r\n    syntheticEvent[key] = undefined\r\n  }\r\n  updaterQueue.isPending = false\r\n  updaterQueue.batchUpdate()\r\n}\r\n\r\nclass SyntheticEvent {\r\n  persist() {\r\n    syntheticEvent = null\r\n  }\r\n}\r\nfunction getSyntheticEvent(nativeEvent : Event) {\r\n  if(!syntheticEvent) {\r\n    syntheticEvent = new SyntheticEvent()\r\n  }\r\n  syntheticEvent[\"nativeEvent\"] = nativeEvent\r\n  for(let key in nativeEvent) {\r\n    const value = nativeEvent[key]\r\n    if(isFunction(value)) {\r\n      syntheticEvent[key] = value.bind(nativeEvent)\r\n    } else {\r\n      syntheticEvent[key] = value\r\n    }\r\n  }\r\n  return syntheticEvent\r\n}\r\n\r\nexport {\r\n  addEventListener,\r\n}", "const TEXT = Symbol.for(\"TEXT\")\r\nconst ELEMENT = Symbol.for(\"ELEMENT\")\r\nconst CLASS_COMPONENT = Symbol.for(\"CLASS_COMPONENT\")\r\nconst FUNCTION_COMPONENT = Symbol.for(\"FUNCTION_COMPONENT\")\r\n\r\nexport {\r\n  TEXT,\r\n  ELEMENT,\r\n  CLASS_COMPONENT,\r\n  FUNCTION_COMPONENT,\r\n}", "import { flatten, hasOwnProperty, onlyOne } from \"../../shared\"\r\nimport { addEventListener } from \"./event\"\r\nimport { CLASS_COMPONENT, ELEMENT, FUNCTION_COMPONENT, TEXT } from \"../../types\"\r\nimport { Component } from \"./component\"\r\nimport { batchedUpdates } from \"./updater\"\r\n\r\nfunction ReactElement(nodeType : Symbol,type : any,key : any,ref : any,props : any,children : Array<any>) {\r\n  const element = {\r\n    nodeType,\r\n    type,\r\n    key,\r\n    ref,\r\n    props,\r\n    children\r\n  }\r\n  return element\r\n}\r\n\r\nfunction createDOM(element : any) : Node {\r\n  element = onlyOne(element)\r\n  let dom : Node\r\n  const { nodeType } = element\r\n  if(nodeType === TEXT) {\r\n    dom = document.createTextNode(element.content)\r\n  } else if(nodeType === ELEMENT){\r\n    dom = createNativeDOM(element)\r\n  } else if(nodeType === CLASS_COMPONENT){\r\n    dom = createClassComponentDOM(element)\r\n  } else if(nodeType === FUNCTION_COMPONENT){\r\n    dom = createFunctionComponentDOM(element)\r\n  } else {\r\n    dom = document.createComment(element.content ? element.content : \"\")\r\n  }\r\n  element.dom = dom\r\n  return dom\r\n}\r\n\r\nfunction createNativeDOM(element : any) : HTMLElement {\r\n  const { type,ref,props,children } = element\r\n  const dom = document.createElement(type)\r\n  ref && setRef(dom,ref)\r\n  props && setProps(dom,props)\r\n  children && createChildrenDOM(dom,children)\r\n  return dom\r\n}\r\n\r\nfunction setRef(current : Node | Component,ref : any) {\r\n  if(ref) {\r\n    ref.current = current\r\n  }\r\n}\r\n\r\nfunction createChildrenDOM(parentNode : Node,children : Array<any>) {\r\n  children && flatten(children).forEach((child,index) => {\r\n    child[\"mountIndex\"] = index\r\n    const childDOM = createDOM(child)\r\n    parentNode.appendChild(childDOM)\r\n  })\r\n}\r\n\r\nfunction setProps(dom : HTMLElement,props : any) {\r\n  for(let key in props) {\r\n    setProp(dom,key,props[key])\r\n  }\r\n}\r\n\r\nfunction setProp(dom : HTMLElement,key : string,value : any) {\r\n  if(/^on/.test(key)) {\r\n    addEventListener(dom,key,value)\r\n  } else if(key === \"className\") {\r\n    dom.className = value\r\n  } else if(key === \"style\") {\r\n    for(let styleName in value) {\r\n      dom.style[styleName] = value[styleName]\r\n    }\r\n  } else {\r\n    dom.setAttribute(key,value)\r\n  }\r\n}\r\n\r\nfunction createClassComponentDOM(element : any) {\r\n  const { type,ref,props } = element\r\n  const componentInstance = new type(props)\r\n  setContext(componentInstance,type)\r\n  setRef(componentInstance,ref)\r\n  componentInstance.componentWillMount()\r\n  const renderElement = componentInstance.render()\r\n  const dom = createDOM(renderElement)\r\n  renderElement.dom = dom\r\n  componentInstance.renderElement = renderElement\r\n  element.componentInstance = componentInstance\r\n  batchedUpdates(() => componentInstance.componentDidMount())\r\n  componentInstance.isOverMount = true\r\n  return dom\r\n}\r\n\r\nfunction setContext(componentInstance : Component,classType : any) {\r\n  if(classType.contextType) {\r\n    componentInstance.context = classType.contextType.Provider.value\r\n  }\r\n}\r\n\r\nfunction createFunctionComponentDOM(element : any) {\r\n  const { type,props } = element\r\n  const renderElement = type(props)\r\n  const dom = createDOM(renderElement)\r\n  renderElement.dom = dom\r\n  element.renderElement = renderElement\r\n  return dom\r\n}\r\n\r\n\r\n\r\nfunction compareTwoElements(oldRenderElement : any,newRenderElement : any) {\r\n  oldRenderElement = onlyOne(oldRenderElement)\r\n  newRenderElement = onlyOne(newRenderElement)\r\n  const currentDOM = oldRenderElement.dom\r\n  let currentElement = oldRenderElement\r\n  if(newRenderElement === null) {\r\n    currentDOM.parentNode.removeChild(currentDOM)\r\n  } else if(oldRenderElement.type !== newRenderElement.type) {\r\n    const newDOM = createDOM(newRenderElement)\r\n    currentDOM.parentNode.replaceChild(newDOM,currentDOM)\r\n    currentElement = newRenderElement\r\n  } else {\r\n    updateElement(oldRenderElement,newRenderElement)\r\n  }\r\n  return currentElement\r\n}\r\n\r\nfunction updateElement(oldElement : any,newElement : any) {\r\n  const currentDOM = newElement.dom = oldElement.dom\r\n  if(oldElement.nodeType === TEXT && newElement.nodeType === TEXT && oldElement.content !== newElement.content) {\r\n    currentDOM.textContent = newElement.content\r\n  } else if(oldElement.nodeType === ELEMENT) {\r\n    updateProps(currentDOM,oldElement.props,newElement.props)\r\n    updateChildrenElement(currentDOM,oldElement.children,newElement.children)\r\n    oldElement.props = newElement.props\r\n  } else if(oldElement.nodeType === CLASS_COMPONENT) {\r\n    updateClassComponent(oldElement,newElement)\r\n  } else if(oldElement.nodeType === FUNCTION_COMPONENT) {\r\n    updateFunctionComponent(oldElement,newElement)\r\n  }\r\n}\r\n\r\nfunction updateProps(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  for(let key in oldProps) {\r\n    if(hasOwnProperty(newProps,key)) {\r\n      dom.removeAttribute(key)\r\n    }\r\n  }\r\n  setProps(dom,newProps)\r\n}\r\n\r\nlet updateDepth = 0\r\nconst diffQueue : Array<any> = []\r\nfunction updateChildrenElement(dom : HTMLElement,oldChildren : Array<any>,newChildren : Array<any>) {\r\n  updateDepth++\r\n  diff(dom,oldChildren,newChildren)\r\n  updateDepth--\r\n  if(updateDepth === 0) {\r\n    patch()\r\n  }\r\n}\r\n\r\nfunction diff(dom : HTMLElement,oldChildren : Array<any>,newChildren : Array<any>) {\r\n  const oldChildrenElementsMap = getChildrenElementsMap(oldChildren)\r\n  const newChildrenElementsMap = getNewChildrenElementsMap(oldChildrenElementsMap,newChildren)\r\n  let lastIndex = 0\r\n  for(let i = 0; i < newChildren.length; i++) {\r\n    const newElement = newChildren[i]\r\n    if(!newElement) {\r\n      const oldElement = oldChildrenElementsMap[i.toString()]\r\n      if(oldElement.componentInstance) {\r\n        oldElement.componentInstance.componentWillUnmount()\r\n      }\r\n      continue\r\n    }\r\n    const newKey = newElement.key || i.toString()\r\n    const oldElement = oldChildrenElementsMap[newKey]\r\n    if(oldElement === newElement) {\r\n      const mountIndex = oldElement.mountIndex\r\n      if(mountIndex < lastIndex) {\r\n        diffQueue.push({\r\n          parentNode: dom,\r\n          type: \"MOVE\",\r\n          fromIndex: mountIndex,\r\n          toIndex: i\r\n        })\r\n      }\r\n      lastIndex = Math.max(mountIndex,lastIndex)\r\n    } else {\r\n      diffQueue.push({\r\n        parentNode: dom,\r\n        type: \"INSERT\",\r\n        toIndex: i,\r\n        dom: createDOM(newElement)\r\n      })\r\n    }\r\n    newElement.mountIndex = i\r\n  }\r\n  for(let oldKey in oldChildrenElementsMap) {\r\n    if(newChildrenElementsMap.hasOwnProperty(oldKey)) {\r\n      const oldElement = oldChildrenElementsMap[oldKey]\r\n      diffQueue.push({\r\n        parentNode: dom,\r\n        type: \"REMOVE\",\r\n        fromIndex: oldElement.mountIndex\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nfunction patch() {\r\n  const deleteMap = {}\r\n  const deleteChildren = []\r\n  for(let i = 0; i < diffQueue.length; i++) {\r\n    const { type,fromIndex,parentNode } = diffQueue[i]\r\n    if(type === \"MOVE\" || type === \"REMOVE\") {\r\n      const oldElement = parentNode.children[fromIndex]\r\n      deleteMap[fromIndex] = oldElement\r\n      deleteChildren.push(oldElement)\r\n    }\r\n  }\r\n  deleteChildren.forEach(child => {\r\n    child.parentNode.removeChild(child)\r\n  })\r\n  for(let i = 0; i < diffQueue.length; i++) {\r\n    const { type,fromIndex,toIndex,parentNode,dom } = diffQueue[i]\r\n    if(type === \"MOVE\") {\r\n      insertChildAt(parentNode,deleteMap[fromIndex],toIndex)\r\n    } else if(type === \"INSERT\") {\r\n      insertChildAt(parentNode,dom,toIndex)\r\n    }\r\n  }\r\n  diffQueue.length = 0\r\n}\r\n\r\nfunction insertChildAt(parentNode : HTMLElement,child : Node,index : number) {\r\n  const oldChild = parentNode.children[index]\r\n  oldChild ? parentNode.insertBefore(child,oldChild) : parentNode.appendChild(child)\r\n}\r\n\r\nfunction getChildrenElementsMap(oldChildren : Array<any>) {\r\n  const oldChildrenElementsMap = {}\r\n  for(let i = 0; i < oldChildren.length; i++) {\r\n    const oldKey = oldChildren[i].key || i.toString()\r\n    oldChildrenElementsMap[oldKey] = oldChildren[i]\r\n  }\r\n  return oldChildrenElementsMap\r\n}\r\n\r\nfunction getNewChildrenElementsMap(oldChildrenElementsMap : any,newChildren : Array<any>) {\r\n  const newChildrenElementsMap = {}\r\n  for(let i = 0; i < newChildren.length; i++) {\r\n    const newElement = newChildren[i]\r\n    if(!newElement) {\r\n      continue\r\n    }\r\n    const newKey = newElement.key || i.toString()\r\n    const oldElement = oldChildrenElementsMap[newKey]\r\n    if(canDeepCompare(oldElement,newElement)) {\r\n      updateElement(oldElement,newElement)\r\n      newChildren[i] = oldElement\r\n    }\r\n    newChildrenElementsMap[newKey] = newChildren[i]\r\n  }\r\n  return newChildrenElementsMap\r\n}\r\n\r\nfunction canDeepCompare(oldElement : any,newElement :any) {\r\n  if(!!oldElement && !!newElement) {\r\n    return oldElement.type === newElement.type\r\n  }\r\n  return false\r\n}\r\n\r\nfunction updateClassComponent(oldElement : any,newElement : any) {\r\n  const componentInstance = newElement.componentInstance = oldElement.componentInstance\r\n  setContext(componentInstance,oldElement.type)\r\n  const nextProps = newElement.props\r\n  componentInstance.componentWillReceiveProps(nextProps)\r\n  componentInstance.state = newElement.type.getDerivedStateFromProps(nextProps,componentInstance.state)\r\n  componentInstance.$updater.emitUpdate(nextProps)\r\n}\r\n\r\nfunction updateFunctionComponent(oldElement : any,newElement : any) {\r\n  const oldRenderElement = oldElement.renderElement\r\n  const newRenderElement = newElement.type(newElement.props)\r\n  const currentElement = compareTwoElements(oldRenderElement,newRenderElement)\r\n  newElement.renderElement = currentElement\r\n}\r\n\r\nexport {\r\n  ReactElement,\r\n  createDOM,\r\n  createNativeDOM,\r\n  createChildrenDOM,\r\n  setProps,\r\n  setProp,\r\n  setRef,\r\n  createClassComponentDOM,\r\n  createFunctionComponentDOM,\r\n  compareTwoElements,\r\n  updateElement,\r\n  updateProps,\r\n  updateChildrenElement,\r\n  updateClassComponent,\r\n  updateFunctionComponent,\r\n}"],
  "mappings": "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",
  "names": []
}
