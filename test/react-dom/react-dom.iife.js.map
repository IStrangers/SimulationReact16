{
  "version": 3,
  "sources": ["../../packages/react-dom/index.ts", "../../packages/shared/src/utils.ts", "../../packages/types/src/nodeType.ts", "../../packages/types/src/effectType.ts", "../../packages/react/src/schedule.ts"],
  "sourcesContent": ["import { scheduleRoot } from \"../react/src/schedule\"\r\nimport { TAG_ROOT } from \"../types\"\r\n\r\nfunction render(element : any, container : Node) {\r\n  const rootFiber = {\r\n    tag: TAG_ROOT,\r\n    stateNode : container,\r\n    props: {\r\n    },\r\n    children: [element]\r\n  }\r\n  scheduleRoot(rootFiber)\r\n}\r\n\r\nexport {\r\n  render,\r\n}", "function isObject(value : any) : boolean {\r\n  return typeof value === 'object'\r\n}\r\n\r\nfunction isNumber(value : any) : boolean {\r\n  return !isNaN(value) && typeof value === 'number'\r\n}\r\n\r\nfunction isString(value : any) : boolean {\r\n  return typeof value === 'string'\r\n}\r\n\r\nfunction isBoolean(value : any) : boolean {\r\n  return typeof value === 'boolean'\r\n}\r\n\r\nfunction isArray(value : any) : boolean {\r\n  return Array.isArray(value)\r\n}\r\n\r\nfunction isFunction(value : any) : boolean {\r\n  return typeof value === 'function'\r\n}\r\n\r\nfunction toUppercaseStart(value : string) : string {\r\n  if(value) {\r\n    value = value.replace(value[0],value[0].toUpperCase());\r\n  }\r\n  return value\r\n}\r\n\r\nfunction isUppercaseStart(value : string) : boolean {\r\n  if(value) {\r\n    const c = value.charAt(0)\r\n    if(c >= \"A\" && c <= \"Z\") {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction hasOwnProperty(value : any,key : any) : boolean {\r\n  return Object.prototype.hasOwnProperty.call(value,key)\r\n} \r\n\r\nfunction removeExtraSpaces(value : string) : string {\r\n  return value.replace(/[\\s]+/g,\"\")\r\n}\r\n\r\nfunction getLongestIncreasingSequence(arr : Array<number>) : Array<number> {\r\n  const len = arr.length\r\n  const result = [0]\r\n  const traceBack = new Array(len)\r\n  let startIndex\r\n  let endIndex\r\n  let middleIndex\r\n  let resultLastIndex;\r\n  for(let i = 0; i < len; i++) {\r\n    let item = arr[i]\r\n    if(item === 0) {\r\n      continue\r\n    }\r\n    resultLastIndex = result[result.length - 1]\r\n    if(arr[resultLastIndex] < item) {\r\n      result.push(i)\r\n      traceBack[i] = resultLastIndex\r\n      continue\r\n    }\r\n\r\n    startIndex = 0\r\n    endIndex = result.length - 1\r\n    while(startIndex < endIndex) {\r\n      middleIndex = ((startIndex + endIndex) / 2) | 0\r\n      if(arr[result[middleIndex]] < item) {\r\n        startIndex = middleIndex  + 1\r\n      } else {\r\n        endIndex = middleIndex\r\n      }\r\n    }\r\n\r\n    if(arr[result[endIndex]] > item) {\r\n      result[endIndex] = i\r\n      traceBack[i] = result[endIndex - 1]\r\n    }\r\n  }\r\n\r\n  let i = result.length\r\n  let last = result[i - 1]\r\n  while(i-- > 0) {\r\n    result[i] = last\r\n    last = traceBack[last]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction invokeFunctions(funs : Array<Function>) {\r\n  for(let i = 0; i < funs.length; i++) {\r\n    const fun = funs[i]\r\n    fun()\r\n  }\r\n}\r\n\r\nfunction onlyOne(items : any) {\r\n  return isArray(items) ? items[0] : items\r\n}\r\n\r\nfunction flatten(array : Array<any>) {\r\n  const flatted : Array<any> = []\r\n  function flat(items : Array<any>) {\r\n    items.forEach(item => {\r\n      if(isArray(item)) {\r\n        flat(item)\r\n      } else {\r\n        flatted.push(item)\r\n      }\r\n    })\r\n  }\r\n  flat(array)\r\n  return flatted\r\n}\r\n\r\nexport {\r\n  isObject,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  isArray,\r\n  isFunction,\r\n  hasOwnProperty,\r\n  toUppercaseStart,\r\n  isUppercaseStart,\r\n  removeExtraSpaces,\r\n  getLongestIncreasingSequence,\r\n  invokeFunctions,\r\n  onlyOne,\r\n  flatten,\r\n}", "const TEXT = Symbol.for(\"TEXT\")\r\n\r\n\r\nconst TAG_ROOT = Symbol.for(\"TAG_ROOT\")\r\nconst TAG_ELEMENT = Symbol.for(\"TAG_ELEMENT\")\r\nconst TAG_TEXT = Symbol.for(\"TAG_TEXT\")\r\nconst TAG_COMMENT = Symbol.for(\"TAG_COMMENT\")\r\n\r\nexport {\r\n  TEXT,\r\n\r\n  TAG_ROOT,\r\n  TAG_ELEMENT,\r\n  TAG_TEXT,\r\n  TAG_COMMENT,\r\n}", "const PLACEMENT = Symbol.for(\"PLACEMENT\")\r\nconst UPDATE = Symbol.for(\"PLACEMENT\")\r\nconst DELETION = Symbol.for(\"PLACEMENT\")\r\n\r\nexport {\r\n  PLACEMENT,\r\n  UPDATE,\r\n  DELETION,\r\n}", "import { hasOwnProperty, isString } from \"../../shared\"\r\nimport { PLACEMENT, TAG_COMMENT, TAG_ELEMENT, TAG_ROOT, TAG_TEXT, TEXT } from \"../../types\"\r\n\r\nlet workInProgressRoot : any = null\r\nlet nextUnitOfWork : any = null\r\nlet currentRoot : any = null\r\n\r\nfunction startWork() {\r\n  requestIdleCallback(workLoop,{ timeout: 500 })\r\n}\r\nstartWork()\r\n\r\nfunction workLoop(deadline : any) {\r\n  let shouldYield = false\r\n  while(nextUnitOfWork && !shouldYield) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\r\n    shouldYield = deadline.timeRemaining() < 1\r\n  }\r\n  if(!nextUnitOfWork && workInProgressRoot) {\r\n    commitRoot()\r\n  }\r\n  startWork()\r\n}\r\n\r\nfunction commitRoot() {\r\n  let currentFiber = workInProgressRoot.firstEffect\r\n  while(currentFiber) {\r\n    commitWork(currentFiber)\r\n    currentFiber = currentFiber.nextEffect\r\n  }\r\n  currentRoot = workInProgressRoot\r\n  workInProgressRoot = null\r\n}\r\n\r\nfunction commitWork(currentFiber : any) {\r\n  if(!currentFiber) return\r\n  const parentFiber = currentFiber.parent\r\n  const parentNode = parentFiber.stateNode\r\n  if(currentFiber.effectTag === PLACEMENT) {\r\n    parentNode.appendChild(currentFiber.stateNode)\r\n  }\r\n  currentFiber.effectTag = null\r\n}\r\n\r\nfunction performUnitOfWork(currentFiber : any) {\r\n  beginWork(currentFiber)\r\n  if(currentFiber.child) {\r\n    return currentFiber.child\r\n  }\r\n  while(currentFiber) {\r\n    completeUnitOfWork(currentFiber)\r\n    if(currentFiber.sibling) {\r\n      return currentFiber.sibling\r\n    }\r\n    currentFiber = currentFiber.parent\r\n  }\r\n}\r\n\r\nfunction completeUnitOfWork(currentFiber : any) {\r\n  const { parent: parentFiber,effectTag } = currentFiber\r\n  if(parentFiber) {\r\n    if(!parentFiber.firstEffect) {\r\n      parentFiber.firstEffect = currentFiber.firstEffect\r\n    }\r\n    if(currentFiber.lastEffect) {\r\n      if(parentFiber.lastEffect) {\r\n        parentFiber.lastEffect.nextEffect = currentFiber.firstEffect\r\n      }\r\n      parentFiber.lastEffect = currentFiber.lastEffect\r\n    }\r\n    if(effectTag) {\r\n      if(parentFiber.lastEffect) {\r\n        parentFiber.lastEffect.nextEffect = currentFiber\r\n      } else {\r\n        parentFiber.firstEffect = currentFiber\r\n      }\r\n      parentFiber.lastEffect = currentFiber\r\n    }\r\n  }\r\n}\r\n\r\nfunction beginWork(currentFiber : any) {\r\n  const { tag } = currentFiber\r\n  if(tag === TAG_ROOT) {\r\n    updateHostRoot(currentFiber)\r\n  } else if(tag === TAG_TEXT) {\r\n    updateHostText(currentFiber)\r\n  } else if(tag === TAG_ELEMENT) {\r\n    updateHostElement(currentFiber)\r\n  }\r\n}\r\n\r\nfunction updateHostElement(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = createDOM(currentFiber)\r\n  } \r\n  const children = currentFiber.children\r\n  reconcileChildren(currentFiber,children)\r\n}\r\n\r\nfunction updateHostText(currentFiber : any) {\r\n  if(!currentFiber.stateNode) {\r\n    currentFiber.stateNode = createDOM(currentFiber)\r\n  }\r\n}\r\n\r\nfunction updateHostRoot(currentFiber : any) {\r\n  const children = currentFiber.children\r\n  reconcileChildren(currentFiber,children)\r\n}\r\n\r\nfunction reconcileChildren(currentFiber : any,children : Array<any>) {\r\n  let childrenIndex = 0\r\n  let prevSibling : any\r\n  while(childrenIndex < children.length) {\r\n    const child = children[childrenIndex++]\r\n    let tag : Symbol\r\n    if(child.type === TEXT) {\r\n      tag = TAG_TEXT\r\n    } else if(isString(child.type)) {\r\n      tag = TAG_ELEMENT\r\n    } else {\r\n      tag = TAG_COMMENT\r\n    }\r\n    const childFiber = {\r\n      tag,\r\n      type: child.type,\r\n      props: child.props,\r\n      children: child.children,\r\n      stateNode: null,\r\n      parent: currentFiber,\r\n      effectTag: PLACEMENT,\r\n      nextEffect: null\r\n    }\r\n    if(childrenIndex === 1) {\r\n      currentFiber.child = childFiber\r\n    } else {\r\n      prevSibling.sibling = childFiber\r\n    }\r\n    prevSibling = childFiber\r\n  }\r\n}\r\n\r\nfunction createDOM(currentFiber : any) {\r\n  const { tag } = currentFiber\r\n  if(tag === TAG_TEXT) {\r\n    return document.createTextNode(currentFiber.children)\r\n  } else if(tag == TAG_ELEMENT) {\r\n    const dom = document.createElement(currentFiber.type)\r\n    updateDOM(dom,{},currentFiber.props)\r\n    return dom\r\n  }\r\n}\r\n\r\nfunction updateDOM(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  setProps(dom,oldProps,newProps)\r\n}\r\n\r\nfunction setProps(dom : HTMLElement,oldProps : any,newProps : any) {\r\n  for(let key in oldProps) {\r\n    if(hasOwnProperty(newProps,key)) {\r\n      dom.removeAttribute(key)\r\n    }\r\n  }\r\n  for(let key in newProps) {\r\n    setProp(dom,key,newProps[key])\r\n  }\r\n}\r\n\r\nfunction setProp(dom : HTMLElement,key : string,value : any) {\r\n  if(/^on/.test(key)) {\r\n    dom[key.toLowerCase()] = value\r\n  } else if(key === \"className\") {\r\n    dom.className = value\r\n  } else if(key === \"style\") {\r\n    for(let styleName in value) {\r\n      dom.style[styleName] = value[styleName]\r\n    }\r\n  } else {\r\n    dom.setAttribute(key,value)\r\n  }\r\n}\r\n\r\nfunction scheduleRoot(rootFiber : any) {\r\n  workInProgressRoot = rootFiber\r\n  nextUnitOfWork = rootFiber\r\n}\r\n\r\nexport {\r\n  scheduleRoot,\r\n}"],
  "mappings": "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",
  "names": []
}
